<!DOCTYPE html>
<html>
<head>
<meta charset="windows-1251">
<style>
table, td {
  border-left: 7px solid LightGoldenRodYellow;
  border-right: 7px solid LightGoldenRodYellow;
  border-collapse: collapse;
}
td {
  padding: 0px;
  text-align: center;
}

td img{
    display: block;
    margin-left: auto;
    margin-right: auto;
}


div {
  font-size: 24px;
  background-color: white; 
  width: 800px;
  height: 224px;
  line-height: 32px;
  overflow-y: auto;
}

.selection {
  background-color: #2020f0;
  color: #ffffff;
}

</style>


<!-- cursor positioning definitions -->

<script type="text/javascript" src="dict/pos.js"></script>

<!-- dictionary definitions -->

<script type="text/javascript" src="dict/dict.js"></script>  
<script type="text/javascript" src="dict/dict_rus.js"></script>
<script type="text/javascript" src="dict/dict_eng.js"></script>

<!-- emoji      definitions -->
<script type="text/javascript" src="dict/emoji_lib.js"></script>  
<script type="text/javascript" src="dict/glyph_lib.js"></script>  


<script>

	// Version
	const current_version = "1.01";

	// approximate settings for table cell widths
	// for table_spans, 2 is an usual "square" key
	// ~ 14 keys per row...
	var  table_spans;

	// precise values for table cell widths, in px
	const cell_widths = [];
	var cell_height = 45, table_width = 800;   //1100 for IDs

	// line height in div
	const line_height = 32;
	// number of text lines in div
	const n_lines_in_div = 7;
	// thickness of the border in the table
	const border_thickness = 7;
	// keyboard background color
	const color_keyboard = "LightGoldenRodYellow";
	// background color of the "right" choice
	const color_right    = "#72e74b";
	// background color of the "wrong" choice
	const color_wrong    = "#99e6ff";

	// emojis height
	const emoji_keyboard_height = 32;
	const emoji_textfield_height = 24;


	// symbol used to define cursor
	const cursor_symbol  = "\u2026";			// horizontal ellipsis
	// start/end of the selection in internal representation of the text
	var selection_start = 0;				// handling cursor...
	var selection_end = 0;
	// internal representation of the typed text
	var typed_text = "";					// text typed by the user
	// positions of '\n' symbols in 'typed_text'
	const enter_positions = [];
	// length of each line in symbols
	const line_lengths = [];
	// current line, in units of px, shown at the top of the div
	var current_scroll_top = 0;
	// top offsets of all lines within div, relative to the div top
	const line_offsetTop = [];
	// top offset of the cursor relative to the div top
	var cursor_offsetTop = 0;

	// current number in the algorithm of search
	var current_num = 0;
	// max number of choices
	const num_bits = 8;
	// start position of the choice selector
	var current_bit = num_bits - 1;

	// number of rows in the present table
	var current_number_of_rows = 0;

	// whether "SHIFT" key has been pressed
	var shift_isactive = 0;		

	var last_touch_id = [];

	// which interface is currently realized:
	// "normal", "pos", "paste", "dict_any", "dict_normal", "dict_cued", "emoji"
	var current_interface = "";

	// in "typed_text" string,
	// '$xxx$' is treated internally as Unicode emoji number "xxx"
	// '$0$' is '$'
	// '$-1$' is '&nbsp;'
	// '$-2$' is 7 non breaking spaces
	// '$-3$' is '<'
	// '$-4$' is '>'

	const NBSP_1 = '&nbsp;';
	const NBSP_2 = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';


	function shift_press()
	{
		shift_isactive = (shift_isactive + 1) % 3;
		//  0 -- shift is not active, 
		//  1 -- shift is active, 
		//  2 -- CAPS LOCK
	}
	
	function Kbd_Button(id1, id2, number, value1, value2, mask1, mask2, handler1, handler2, args1, args2)
	{
	    // id2 -- alternative cell, for "Enter" button
	    // value, mask, handler -> 2 for active "Shift"
	    this.id1 = id1;
	    this.id2 = id2;
	    this.number = number;
	    this.value1 = value1;
	    this.value2 = value2;
	    this.mask1 = mask1;
	    this.mask2 = mask2;
	    this.handler1 = handler1;
	    this.handler2 = handler2;
	    if (args1 !== undefined)
	    {
		this.args1 = args1;
	    }
	    else
	    {
		this.args1 = [];
	    }

	    if (args2 !== undefined)
	    {
		this.args2 = args2;
	    }
	    else
	    {
		this.args2 = [];
	    }

	}
	  
	var button_list, emoji_list;

	function init_main_keyboard()
	{
		table_spans = [	
				 2,     2,   2,   2, 2, 2,  2, 2, 2, 2, 2,  2, 2,  4,  0,			// 14 keys, sum_spans = 30
				 3,     2,   2,   2, 2, 2,  2, 2, 2, 2, 2,  2, 2,  3,  0,			// 14 keys
				 4,     2,   2,   2, 2, 2,  2, 2, 2, 2, 2,  2, 2,  2,  0,			// 13 keys (Enter -> -1)
				 5,     2,   2,   2, 2, 2,  2, 2, 2, 2, 2,  2, 3,  0,				// 13 keys
				 26.4,  1.8, 1.8, 0 								// 3 keys, total of 57
//				 , 1, 0
		  	      ];

		
	}

	function init_custom_simple_keyboard(key_rows, key_columns, max_keys)
	{
		var i, j, len = 0, cur_keys = 0;

		table_spans = [];
		for (i=0; i<key_rows && cur_keys < max_keys; i++)
		{
			for(j=0; j<key_columns && cur_keys < max_keys; j++)
			{
				table_spans[len] = 1;
				len ++;
				cur_keys ++;
			}
			table_spans[len] = 0;
			len ++;
		}
	}

//	const emoji_button = "<span style=\"color:red\">&#x2661;</span>";
	const emoji_button = "&#x2661;";

	function init_button_list_rus()
	{
	    button_list = [
	    new Kbd_Button("Key_0_0" ,       null,  tri('121     '), '\u0394', '\u0394',   "ESC",      "ESC", null, null),		// "Delta" sign
	    new Kbd_Button("Key_0_1" ,       null,  tri('1100    '),  "1",  "@",        null,       null, null, null),
	    new Kbd_Button("Key_0_2" ,       null,  tri('1101    '),  "2",  "!",        null,       null, null, null),
	    new Kbd_Button("Key_0_3" ,       null,  tri('1102    '),  "3",  "?",        null,       null, null, null),
	    new Kbd_Button("Key_0_4" ,       null,  tri('11100   '),  "4",  ";",        null,       null, null, null),
	    new Kbd_Button("Key_0_5" ,       null,  tri('11101   '),  "5",  ":",        null,       null, null, null),
	    new Kbd_Button("Key_0_6" ,       null,  tri('11110   '),  "6",  "%",        null,       null, null, null),			
	    new Kbd_Button("Key_0_7" ,       null,  tri('11111   '),  "7",  "\u2116",   null,       null, null, null),			// 'numero' sign
	    new Kbd_Button("Key_0_8" ,       null,  tri('1121    '),  "8",  "~",        null,       null, null, null),
	    new Kbd_Button("Key_0_9" ,       null,  tri('1122    '),  "9",  "(",        null,       null, null, null),
	    new Kbd_Button("Key_0_10",       null,  tri('1120    '),  "0",  ")",        null,       null, null, null),
	    new Kbd_Button("Key_0_11",       null,  tri('1221    '),  "-",  "+",        null,       null, null, null),
	    new Kbd_Button("Key_0_12",       null,  tri('1220    '),  ",",  ".",        null,       null, null, null),
	    new Kbd_Button("Key_0_13",       null,  tri('1202    '), null, null,      "BKSP",      "DEL", backspaceInTextarea, delInTextarea),			

	    new Kbd_Button("Key_1_0" ,       null,  tri('1002    '), null, null,      "SAVE",       null, null, null),
	    new Kbd_Button("Key_1_1" ,       null,  tri('02210   '),  "\u0439",  "\u0419",        null,       null, null, null),	//	'\u0439'
	    new Kbd_Button("Key_1_2" ,       null,  tri('022210  '),  "\u0446",  "\u0426",        null,       null, null, null),	//	'\u0446'
	    new Kbd_Button("Key_1_3" ,       null,  tri('02100   '),  "\u0443",  "\u0423",        null,       null, null, null),	//	'\u0443'
	    new Kbd_Button("Key_1_4" ,       null,  tri('02000   '),  "\u043a",  "\u041a",        null,       null, null, null),	//	'\u043A'
	    new Kbd_Button("Key_1_5" ,       null,  tri('0001    '),  "\u0435",  "\u0415",        null,       null, null, null),	//	'\u0435'
	    new Kbd_Button("Key_1_6" ,       null,  tri('0100    '),  "\u043d",  "\u041d",        null,       null, null, null),	//	'\u043D'
	    new Kbd_Button("Key_1_7" ,       null,  tri('02120   '),  "\u0433",  "\u0413",        null,       null, null, null),	//	'\u0433'
	    new Kbd_Button("Key_1_8" ,       null,  tri('022200  '),  "\u0448",  "\u0428",        null,       null, null, null),	//	'\u0448'
	    new Kbd_Button("Key_1_9" ,       null,  tri('022211  '),  "\u0449",  "\u0429",        null,       null, null, null),	//	'\u0449'
	    new Kbd_Button("Key_1_10",       null,  tri('02122   '),  "\u0437",  "\u0417",        null,       null, null, null),	//	'\u0437'
	    new Kbd_Button("Key_1_11",       null,  tri('02211   '),  "\u0445",  "\u0425",        null,       null, null, null),	//	'\u0445'
	    new Kbd_Button("Key_1_12",       null,  tri('022222  '),  "\u044a",  "\u042a",        null,       null, null, null),	//	'\u044A'
	    new Kbd_Button("Key_1_13", "Key_2_13",  tri('1201    '),  '\n',      '\n\n', "ENTER", "ENTER x2", null, null),
	    
	    new Kbd_Button("Key_2_0" ,       null,  tri('1000    '), null, null,        "ENG",      "ENG",  init_button_list_eng, init_button_list_eng),
	    new Kbd_Button("Key_2_1" ,       null,  tri('022221  '),  "\u0444",  "\u0424",        null,       null, null, null),	//	'\u0444'
	    new Kbd_Button("Key_2_2" ,       null,  tri('02110   '),  "\u044b",  "\u042b",        null,       null, null, null),	//	'\u044B'
	    new Kbd_Button("Key_2_3" ,       null,  tri('0120    '),  "\u0432",  "\u0412",        null,       null, null, null),	//	'\u0432'
	    new Kbd_Button("Key_2_4" ,       null,  tri('0010    '),  "\u0430",  "\u0410",        null,       null, null, null),	//	'\u0430'
	    new Kbd_Button("Key_2_5" ,       null,  tri('02011   '),  "\u043f",  "\u041f",        null,       null, null, null),	//	'\u043F'
	    new Kbd_Button("Key_2_6" ,       null,  tri('0111    '),  "\u0440",  "\u0420",        null,       null, null, null),	//	'\u0440'
	    new Kbd_Button("Key_2_7" ,       null,  tri('0000    '),  "\u043e",  "\u041e",        null,       null, null, null),	//	'\u043E'
	    new Kbd_Button("Key_2_8" ,       null,  tri('0121    '),  "\u043b",  "\u041b",        null,       null, null, null),	//	'\u043B'
	    new Kbd_Button("Key_2_9" ,       null,  tri('02010   '),  "\u0434",  "\u0414",        null,       null, null, null),	//	'\u0434'
	    new Kbd_Button("Key_2_10",       null,  tri('02212   '),  "\u0436",  "\u0416",        null,       null, null, null),	//	'\u0436'
	    new Kbd_Button("Key_2_11",       null,  tri('022220  '),  "\u044d",  "\u042d",        null,       null, null, null),	//	'\u044D'
	    new Kbd_Button("Key_2_12",       null,  tri('1222    '),  "\"", "'",        null,       null, null, null),                    	
	                                                       
	    new Kbd_Button("Key_3_0" ,       null,  tri('1001    '), null, null,     "SHIFT","CAPS LOCK", shift_press, shift_press),	
	    new Kbd_Button("Key_3_1" ,       null,  tri('02101   '),  "\u044f",  "\u042f",        null,       null, null, null),	//	'\u044F'
	    new Kbd_Button("Key_3_2" ,       null,  tri('02201   '),  "\u0447",  "\u0427",        null,       null, null, null),	//	'\u0447'
	    new Kbd_Button("Key_3_3" ,       null,  tri('0110    '),  "\u0441",  "\u0421",        null,       null, null, null),	//	'\u0441'
	    new Kbd_Button("Key_3_4" ,       null,  tri('02001   '),  "\u043c",  "\u041c",        null,       null, null, null),	//	'\u043C'
	    new Kbd_Button("Key_3_5" ,       null,  tri('0011    '),  "\u0438",  "\u0418",        null,       null, null, null),	//	'\u0438'
	    new Kbd_Button("Key_3_6" ,       null,  tri('0101    '),  "\u0442",  "\u0422",        null,       null, null, null),	//	'\u0442'
	    new Kbd_Button("Key_3_7" ,       null,  tri('02111   '),  "\u044c",  "\u042c",        null,       null, null, null),	//	'\u044C'
	    new Kbd_Button("Key_3_8" ,       null,  tri('02200   '),  "\u0431",  "\u0411",        null,       null, null, null),	//	'\u0431'
	    new Kbd_Button("Key_3_9" ,       null,  tri('022201  '),  "\u044e",  "\u042e",        null,       null, null, null),	//	'\u044E'
	    new Kbd_Button("Key_3_10",       null,  tri('1010    '), null, null,    "\u2190",   "\u2193", moveCursorLeft, moveCursorDown),		// "left",     "down",
	    new Kbd_Button("Key_3_11",       null,  tri('1011    '), null, null,    "\u2192",   "\u2191", moveCursorRight, moveCursorUp),		// "right",      "up",
	    new Kbd_Button("Key_3_12",       null,  tri('1020    '), null, null,      "\u0441\u043B\u043E\u0432\u043E",    "\u0441\u043B\u043E\u0432\u043E",    start_any_dict, start_any_dict, "rus", "rus"),	
                                                               
	    new Kbd_Button("Key_4_0" ,       null,  tri('1200    '),  "$-1$", "$-2$", "SPACE", "TAB", null, null),
	    new Kbd_Button("Key_4_1" ,       null,  tri('1021    '),  null, null, emoji_button, emoji_button, start_rus_emoji, start_rus_emoji),
	    new Kbd_Button("Key_4_2" ,       null,  tri('1022    '),  null, null,    "pos",       "pos",    realize_pos_keyboard,     realize_pos_keyboard,  "rus", "rus")

//	   ,new Kbd_Button("Key_5_0" ,       null,  tri('10221   '),  null, null,    "temp",      "temp",   test_dict,     test_dict,  "rus", "rus")
	    ];     
	}



	function init_button_list_eng()
	{
	    button_list = [
	    new Kbd_Button("Key_0_0" ,       null,  tri('121     '), '\u0394', '\u0394',   "ESC",      "ESC", null, null),		// "Delta" sign
	    new Kbd_Button("Key_0_1" ,       null,  tri('11000   '),  "1",  "!",        null,       null, null, null),
	    new Kbd_Button("Key_0_2" ,       null,  tri('11001   '),  "2",  "@",        null,       null, null, null),
	    new Kbd_Button("Key_0_3" ,       null,  tri('11010   '),  "3",  "#",        null,       null, null, null),
	    new Kbd_Button("Key_0_4" ,       null,  tri('11011   '),  "4",  "$0$",      null,        "$", null, null),
	    new Kbd_Button("Key_0_5" ,       null,  tri('11100   '),  "5",  "%",        null,       null, null, null),
	    new Kbd_Button("Key_0_6" ,       null,  tri('11101   '),  "6",  "^",        null,       null, null, null),			
	    new Kbd_Button("Key_0_7" ,       null,  tri('11110   '),  "7",  "&",        null,       null, null, null),
	    new Kbd_Button("Key_0_8" ,       null,  tri('11111   '),  "8",  "*",        null,       null, null, null),
	    new Kbd_Button("Key_0_9" ,       null,  tri('11200   '),  "9",  "(",        null,       null, null, null),
	    new Kbd_Button("Key_0_10",       null,  tri('11201   '),  "0",  ")",        null,       null, null, null),
	    new Kbd_Button("Key_0_11",       null,  tri('11210   '),  "-",  "_",        null,       null, null, null),
	    new Kbd_Button("Key_0_12",       null,  tri('11211   '),  "=",  "+",        null,       null, null, null),
	    new Kbd_Button("Key_0_13",       null,  tri('1200    '), null, null,      "BKSP",      "DEL", backspaceInTextarea, delInTextarea),			

	    new Kbd_Button("Key_1_0" ,       null,  tri('1000    '), null, null,      "SAVE",       null, null, null),
	    new Kbd_Button("Key_1_1" ,       null,  tri('02221   '),  "q",  "Q",        null,       null, null, null),
	    new Kbd_Button("Key_1_2" ,       null,  tri('02110   '),  "w",  "W",        null,       null, null, null),			
	    new Kbd_Button("Key_1_3" ,       null,  tri('0000    '),  "e",  "E",        null,       null, null, null),
	    new Kbd_Button("Key_1_4" ,       null,  tri('0112    '),  "r",  "R",        null,       null, null, null),
	    new Kbd_Button("Key_1_5" ,       null,  tri('0001    '),  "t",  "T",        null,       null, null, null),
	    new Kbd_Button("Key_1_6" ,       null,  tri('02120   '),  "y",  "Y",        null,       null, null, null),
	    new Kbd_Button("Key_1_7" ,       null,  tri('0202    '),  "u",  "U",        null,       null, null, null),
	    new Kbd_Button("Key_1_8" ,       null,  tri('0100    '),  "i",  "I",        null,       null, null, null),
	    new Kbd_Button("Key_1_9" ,       null,  tri('0011    '),  "o",  "O",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_1_10",       null,  tri('02200   '),  "p",  "P",        null,       null, null, null),
	    new Kbd_Button("Key_1_11",       null,  tri('12220   '),  "[",  "{",        null,       null, null, null),
	    new Kbd_Button("Key_1_12",       null,  tri('12221   '),  "]",  "}",        null,       null, null, null),
	    new Kbd_Button("Key_1_13", "Key_2_13",  tri('1201    '), '\n', '\n\n', "ENTER", "ENTER x2", null, null),
	    
	    new Kbd_Button("Key_2_0" ,       null,  tri('1001    '), null, null,        "RUS",      "RUS",  init_button_list_rus, init_button_list_rus),
	    new Kbd_Button("Key_2_1" ,       null,  tri('0010    '),  "a",  "A",        null,       null, null, null),
	    new Kbd_Button("Key_2_2" ,       null,  tri('0110    '),  "s",  "S",        null,       null, null, null),
	    new Kbd_Button("Key_2_3" ,       null,  tri('0200    '),  "d",  "D",        null,       null, null, null),
	    new Kbd_Button("Key_2_4" ,       null,  tri('02111   '),  "f",  "F",        null,       null, null, null),
	    new Kbd_Button("Key_2_5" ,       null,  tri('02121   '),  "g",  "G",        null,       null, null, null),
	    new Kbd_Button("Key_2_6" ,       null,  tri('0111    '),  "h",  "H",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_2_7" ,       null,  tri('02220   '),  "j",  "J",        null,       null, null, null),
	    new Kbd_Button("Key_2_8" ,       null,  tri('02211   '),  "k",  "K",        null,       null, null, null),
	    new Kbd_Button("Key_2_9" ,       null,  tri('0201    '),  "l",  "L",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_2_10",       null,  tri('12210   '),  ";",  ":",        null,       null, null, null),
	    new Kbd_Button("Key_2_11",       null,  tri('12211   '),  "\"", "'",        null,       null, null, null),
	    new Kbd_Button("Key_2_12",       null,  tri('12212   '),  "/", "\\",        null,       null, null, null),
	                                                         
	    new Kbd_Button("Key_3_0" ,       null,  tri('1002    '), null, null,     "SHIFT","CAPS LOCK", shift_press, shift_press),	// early end, bit 6
	    new Kbd_Button("Key_3_1" ,       null,  tri('02222   '),  "z",  "Z",        null,       null, null, null),
	    new Kbd_Button("Key_3_2" ,       null,  tri('02212   '),  "x",  "X",        null,       null, null, null),
	    new Kbd_Button("Key_3_3" ,       null,  tri('02100   '),  "c",  "C",        null,       null, null, null),
	    new Kbd_Button("Key_3_4" ,       null,  tri('02210   '),  "v",  "V",        null,       null, null, null),
	    new Kbd_Button("Key_3_5" ,       null,  tri('02201   '),  "b",  "B",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_3_6" ,       null,  tri('0101    '),  "n",  "N",        null,       null, null, null),
	    new Kbd_Button("Key_3_7" ,       null,  tri('02101   '),  "m",  "M",        null,       null, null, null),
	    new Kbd_Button("Key_3_8" ,       null,  tri('12200   '),  ",",  "$-3$",     null,       "<", null, null),
	    new Kbd_Button("Key_3_9" ,       null,  tri('12201   '),  ".",  "$-4$",     null,       ">", null, null),
	    new Kbd_Button("Key_3_10",       null,  tri('1010    '), null, null,    "\u2190",   "\u2193", moveCursorLeft, moveCursorDown),		// "left",     "down",
	    new Kbd_Button("Key_3_11",       null,  tri('1011    '), null, null,    "\u2192",   "\u2191", moveCursorRight, moveCursorUp),		// "right",      "up",
//	    new Kbd_Button("Key_3_12",       null,  tri('1012    '), null, null,        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_3_12",       null,  tri('1020    '), null, null,      "word",       "word",  start_any_dict, start_any_dict, "eng", "eng"),

                                                                 
	    new Kbd_Button("Key_4_0" ,       null,  tri('1202    '),  "$-1$", "$-2$", "SPACE", "TAB", null, null),
	    new Kbd_Button("Key_4_1" ,       null,  tri('1021    '),  null, null, emoji_button, emoji_button, start_eng_emoji, start_eng_emoji),
	    new Kbd_Button("Key_4_2" ,       null,  tri('1022    '),  null, null,    "pos",       "pos",    realize_pos_keyboard,     realize_pos_keyboard,  "eng", "eng")

	    ];     
	}


/*
//	    new Kbd_Button("Key_0_13",       null,  tri('11001000'), null, null,      "BKSP",      "DEL", backspaceInTextarea, delInTextarea),			// early end, bit 6


	    new Kbd_Button("Key_0_6" ,       null,  tri('00111000'),  "6",  "%",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_1_2" ,       null,  tri('00011000'),  "\u0446",  "\u0426",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_1_9" ,       null,  tri('11111000'),  "\u0449",  "\u0429",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_2_6" ,       null,  tri('01101000'),  "\u0440",  "\u0420",        null,       null, null, null),			// early end, bit 6

	    new Kbd_Button("Key_2_9" ,       null,  tri('10011000'),  "\u0434",  "\u0414",        null,       null, null, null),			// early end, bit 6
	    new Kbd_Button("Key_3_0" ,       null,  tri('01000000'), null, null,     "SHIFT","CAPS LOCK", shift_press, shift_press),	// early end, bit 6
	    new Kbd_Button("Key_3_5" ,       null,  tri('01110000'),  "\u0438",  "\u0418",        null,       null, null, null),			// early end, bit 6

	    new Kbd_Button("Key_3_12",       null,  tri('10111000'), null, null,        null,       null, null, null),			// early end, bit 6
*/



	// other functions
	//
	// powers of 3
	const tri_digits = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43046721, 129140163, 387420489, 1162261467];
	
	
/*	function bin(str)
	{
		return(parseInt(str, 2));
	}*/

	function tri(str)
	{
//		return(parseInt(str, 3));
		return(parseInt(str.replaceAll(' ', '0'), 3));
	}



	function tri_op(a, b, operation)
	{
		// digit-wise binary operation
		//
		// for each pair of ternary digits, 'and' is defined as
		// 0 & 0 = 0, 0 & 1 = 0, 0 & 2 = 0, 1 & 2 = 2, 2 & 2 = 1
		// (multiplication for GF3 algebra)
		//
		// for each pair of ternary digits, 'xor' is defined as
		// 0 ^ 0 = 0, 0 ^ 1 = 2, 0 ^ 2 = 1,
		// 1 ^ 0 = 1, 1 ^ 1 = 0, 1 ^ 2 = 2,
		// 2 ^ 0 = 0, 2 ^ 1 = 1, 2 ^ 2 = 0
		// (subtraction for GF3 algebra)


		var c_sum, c_dig, i, a_cur, b_cur, a_rem, b_rem, a_dig, b_dig;
		c_sum = 0;
		a_cur = a;
		b_cur = b;

		for (i = tri_digits.length - 1; i >= 0; i--)
		{
			a_rem = a_cur % tri_digits[i];
			b_rem = b_cur % tri_digits[i];

			a_dig = (a_cur - a_rem) / tri_digits[i];
			b_dig = (b_cur - b_rem) / tri_digits[i];

			a_cur = a_rem;
			b_cur = b_rem;

			if (a_dig > 2 || b_dig > 2 || a_dig < 0 || b_dig < 0)
			{
				alert('Overflow error in ternary_op(' + a + ', ' + b + '; ' + operation + ')');
				return 0;
			}

			if (operation == 'and')
			{
				c_dig = (a_dig * b_dig) % 3;
			}
			else if (operation == 'xor')
			{
				c_dig = (3 + a_dig - b_dig) % 3;
			}
			else
			{
				alert('Unrecognized operation error in ternary_op(' + a + ', ' + b + '; ' + operation + ')');
				return 0;
			}

			c_sum += c_dig * tri_digits[i];
		}

		return c_sum;
	}


	function cell_dblclick()
	{
//		alert(this.id);
		mouse_input_to_table(this.id, 1);
	}


	function cell_onclick()
	{
//		alert(this.innerHTML);
//		alert(this.id);
//		alert(this.key_number);
		mouse_input_to_table(this.id, 0);
	}

	function cell_ontouchstart()
	{
		var second_tap = 0;
		if (last_touch_id == this.id)
		{
			second_tap = 1;
			last_touch_id = [];
		}
		else
		{
			last_touch_id = this.id;
		}

		mouse_input_to_table(this.id, second_tap);
	}




	function mouse_input_to_table(cur_id, whether_apply)
	{
		if (whether_apply != 0 && whether_apply != 1)
		{
			alert('mouse_input_to_table: wrong whether_apply value');
			return;
		}

		var i, j;

		var master_mask = tri_digits[num_bits + 1] - tri_digits[current_bit + 1];
		var current_mask = tri_digits[current_bit];
		var cur_dir;
		var active_buttons_number, made_a_change;


		for (i = 0; i < button_list.length; i++)
		{
			if (button_list[i].id1 == cur_id || button_list[i].id2 == cur_id)
			{
//				alert(i);
				made_a_change = 0;

				if ( tri_op(tri_op(button_list[i].number, current_num, 'xor'), master_mask, 'and') == 0 )
				{
					// interactive button
					cur_dir = tri_op(tri_op(button_list[i].number, current_num, 'xor'), current_mask, 'and') / current_mask;

					if (cur_dir != 0)
					{
						// cur_dir == 1 or 2
						set_dir = 3 - cur_dir * 2;
						change_choice(set_dir);
					}
//					alert(cur_dir);

					if (whether_apply == 1)
					{
						// double click
						apply_choice();

						made_a_change = 1;
					}
				}
				else
				{
					// inactive button
					if (whether_apply == 1)
					{
						undo_choice();
						made_a_change = 1;
					}
				}

				if (made_a_change == 1)
				{
					active_buttons_number = update_table(0);

					if (active_buttons_number < 0)
					{
						mouse_input_to_table(cur_id, 0);
					}
				}

				return;
			}
		}

		
	}


	
	function update_table(actually_update)
	{
		// 'active' buttons are the ones for which all the upper digits coincide with those of the number
		// 'chosen' buttons are active buttons for which the current digit coincides with that of the number
		//
		// if 'actually_update' == 0
		// the function returns the number of the active button, if there's only one,
		// or minus the number of active buttons, if there are more
		//
		// if actually_update > 0, the function returns the same value as above, but also actually updates the document
		// if actually_update < 0, the function returns the number of chosen buttons

	/*
		var current_num = 0;
		const num_bits = 8;
		var current_bit = 7;
		var shift_isactive = 0;
	*/

		var i;
		var cell1, cell2;
		var num_active_buttons = 0, last_active_button = -1, num_chosen_buttons = 0;
		var master_mask = tri_digits[num_bits+1] - tri_digits[current_bit + 1];
		var current_mask = tri_digits[current_bit];
		var current_color;
		var current_text_mask, current_text_value;
		var cellText = null;


		for (i = 0; i < button_list.length; i++)
		{
			cell1 = document.getElementById(button_list[i].id1);
			cell2 = document.getElementById(button_list[i].id2);

			if ( tri_op(tri_op(button_list[i].number, current_num, 'xor'), master_mask, 'and') != 0 )
			{
				// inactive button
				current_color = color_keyboard;
			}
			else
			{
				// interactive button
				num_active_buttons ++;
				last_active_button = i;
				if (  tri_op(tri_op(button_list[i].number, current_num, 'xor'), current_mask, 'and') == 0  )
				{
					// match
					current_color = color_right;
					num_chosen_buttons ++;
				}
				else
				{
					// other choice
					current_color = color_wrong;
				}
			}

			if (actually_update > 0)
			{
				// update the document!
				//
				// update color
				cell1.style.backgroundColor = current_color;
				if (cell2 != null)
				{
					cell2.style.backgroundColor = current_color;
					cell2.style.borderTop = border_thickness + "px solid " + current_color;		// to paint "Enter" button
				}

				// update text
				if (shift_isactive == 0)
				{
					// SHIFT is inactive
					current_text_mask  = button_list[i].mask1;
					current_text_value = button_list[i].value1;
				}
				else
				{
					current_text_mask  = button_list[i].mask2;
					current_text_value = button_list[i].value2;
				}

				cellText = null;
				if (current_text_mask != null)
				{
				      	cellText = current_text_mask;
				}
				else if (current_text_value != null)
				{
				      	cellText = current_text_value;
				}
				else
				{
				      	cellText = "";
				}

				cell1.innerHTML = cellText;
			}

		}

		if (actually_update >= 0)
		{
			if (num_active_buttons == 0)
			{
				alert("Error in 'update_table': num_active_buttons is zero!");
			}
			else if (num_active_buttons == 1)
			{
				return last_active_button;
			}
			else
			{
				return ( -num_active_buttons );
			}
		}
		else
		{
			return num_chosen_buttons;
		}
	}

	function change_choice(direction)
	{
		// direction == +1, move in one direction
		// direction == -1, move in another direction

		if (direction != 1 && direction != -1)
		{
			alert ("Unacceptable input for change_choice(" + direction + ")!");
			return;
		}

		var i;
		var where_to_move = (3 - direction) % 3;
		for(i = 0; i < 2; i++)
		{
			current_num = tri_op(current_num, tri_digits[current_bit] * where_to_move, 'xor');
			if (update_table(-1) > 0)
			{
				// positive number of chosen buttons
				break;
			}
		}

		update_table(1);
	}

	function undo_choice()
	{
		if (current_bit < num_bits - 1)
		{
			current_bit ++;
		}
		// alert('current bit == ' + current_bit.toString());
		update_table(1);
	}

	function store_current_num_and_bit(restore = 0)
	{
		// save or load current_num and current_bit
		if (restore == 0)
		{
			store_current_num_and_bit.cur_num = current_num;
			store_current_num_and_bit.cur_bit = current_bit;
		}
		else
		{
//			alert('here');
			if (typeof store_current_num_and_bit.cur_num != "undefined")
			{
//				alert('and here');
				current_num = store_current_num_and_bit.cur_num;
				current_bit = store_current_num_and_bit.cur_bit;
			}
		}
	}


	function apply_choice()
	{
	/*
		var current_num = 0;
		const num_bits = 8;
		var current_bit = 7;
		var shift_isactive = 0;
	*/
		var current_handler, current_text, current_args = [];

		var active_button = 0, old_shift_isactive, chosen_buttons = 0;
		if (current_bit <= 0)
		{
			alert('Error, current_bit == ' + current_bit);
		}
		else
		{
			current_bit --;

			active_button = update_table(0); 	// just get the return value...

			if (active_button >= 0)			// only one active button
			{
				// active_button is pressed!
				old_shift_isactive = shift_isactive;
				if (shift_isactive == 0)
				{
					current_handler = button_list[active_button].handler1;
					current_text = button_list[active_button].value1;
					current_args = button_list[active_button].args1;
				}
				else
				{
					// SHIFT was pressed!
					current_handler = button_list[active_button].handler2;
					current_text = button_list[active_button].value2;
					current_args = button_list[active_button].args2;
				}

				store_current_num_and_bit();		// for "sticky" buttons

				current_num = 0;
				current_bit = num_bits - 1;

				if (current_handler != null)
				{
					// call that function...
					current_handler(current_args);
				}
				else if (current_text != null)
				{
					typeInTextarea(current_text);
				}

				// if SHIFT was active, and was not repeatedly pressed, inactivate SHIFT
				if (old_shift_isactive == 1 && shift_isactive < 2)
				{
					shift_isactive = 0;
				}

			}
			else
			{
				chosen_buttons = update_table(-1);	// number of chosen buttons
				if (chosen_buttons == 0)
				{
					// shouldn't end up with empty choice...
					change_choice(1);
				}
			}

			update_table(1);		// redraw in any case...

		}
	}



	// =====================================================================================================================
	//
	// textArea related functions

//	const cursor_symbol  = "\u2026";			// horizontal ellipsis

	function typeInTextarea(newText) 
	{
		var start = selection_start;
		var end = selection_end;

		if (start > end)
		{
			[start, end] = [end, start];
		}

		const before = typed_text.substring(0, start);
		const after  = typed_text.substring(end, typed_text.length);
		typed_text = (before + newText + after);

		selection_end = start + newText.length;
		selection_start = selection_end;

		renderTextToInnerHTML();
	}

	function deletingInTextarea(num_backspace, num_del) 
	{
		var start = selection_start;
		var end = selection_end;
		var dollar_sign_counts = 0;

		if (start > end)
		{
			[start, end] = [end, start];
		}

		var i = 0;
//		start -= num_backspace;
		for (i = 0; i < num_backspace; i++)
		{
			if (num_del == 0 && end > start && i == 0)
			{
				continue;
			}
			
			do
			{
				start --;
				if (typed_text.charAt(start) == '$' )
				{
					dollar_sign_counts ++;
				}
			}
			while ( dollar_sign_counts % 2 != 0 && start >= 0);
		}

		if (start < 0)
		{
			start = 0;
		}

//		end += num_del;
		dollar_sign_counts = 0;
		for (i = 0; i < num_del; i++)
		{
			do
			{
				if (typed_text.charAt(end) == '$' )
				{
					dollar_sign_counts ++;
				}
				end ++;
			}
			while ( dollar_sign_counts % 2 != 0 && end <= typed_text.length);
		}

		if (end > typed_text.length)
		{
			end = typed_text.length;
		}

		const before = typed_text.substring(0, start);
		const after  = typed_text.substring(end, typed_text.length);
		typed_text = (before + after);

		selection_end = start;
		selection_start = start;


		renderTextToInnerHTML();
	}

	function backspaceInTextarea() 
	{
		deletingInTextarea(1, 0);
	}

	function delInTextarea() 
	{
		deletingInTextarea(0, 1);
	}

	function crawl_through_string(str, loc_count)
	{
		// crawl through string... find the number of symbols, glyph-aware, or find the position of the loc_count'th symbol
		var i;
		var dollar_sign_counts = 0;
		var count_to = -1;
		if (typeof loc_count != 'undefined') 
		{
			count_to = loc_count;
		}
		var number_of_symbols = 0;

		if (count_to == 0)
		{
			return 0;
		}

		for (i = 0; i < str.length; i++)
		{
			if (str.charAt(i) == '$' )
			{
				dollar_sign_counts ++;
			}

			if (dollar_sign_counts % 2 == 0)
			{
				number_of_symbols ++;
				if (number_of_symbols == count_to)
				{
					return i + 1;
				}
			}
		}

		if (count_to > 0)
		{
			return i;
		}
		else
		{
//			alert('crawl_through_string(\'' + str + '\') = ' + number_of_symbols.toString());
			return number_of_symbols;
		}

	}

	function is_alphanumeric(chr)
	{
		// chr is a character
		return (chr >= '0' && chr <= '9') || (chr >= 'A' && chr <= 'Z') || (chr >= 'a' && chr <= 'z') ||
//		       (chr >= "\u0430" && chr <= "\u044f") && (chr >= "\u0410" && chr <= "\u042f");
		       (chr >= "\u0410" && chr <= "\u044f") && (chr != "\u0401") && (chr != "\u0451");
	}

	function is_numeric(chr)
	{
		// chr is a character
		return (chr >= '0' && chr <= '9') ;
	}


	function get_last_word(change_selection = 1)
	{
		// the function retrieves the last word before the cursor
		// and selects it
		// if change_selection != 0, then also change the selection (default behavior)
		var right = selection_end, left;
		left = 0;
		var i;

		i = right - 1;
		if (i >= 0)
		{
			for (; i >= 0; i --)
			{
				if (! is_alphanumeric(typed_text.charAt(i)))
				{
					left = i + 1;
					break;
				}
			}
		}

		if (change_selection != 0)
		{
			selection_start = left;

//			alert('left = ' + left.toString());
//			alert('selection_start = ' + selection_start.toString());
			// render selection...
			renderTextToInnerHTML();
		}

		return typed_text.substring(left, right);
	}


	function moveCursor(direction, mode = 0)
	{
		// mode == 0:	simply moving a cursor
		// mode == 1:   moving a cursor, leaving selection_start intact
		// mode == 2:   moving selection_start, leaving the cursor (selection_end) intact
		// direction:   "left", "right", "up" or "down"
		//
		// return value: Array, first item is character at 'pos', second item is pos

		var start = selection_start;
		var end = selection_end;
		var pos;

//		const enter_positions = [];
//		const line_lengths = [];
		processEnterPositions();

		// current position
		var pos_line = 0, pos_column = 0;
		// new position relative to the text
		var new_pos = 0;

		var i;

		// $...$ sequences need to be processed as a single symbol

		var dollar_sign_counts = 0;


		// store in pos, whichever of the two pointers I'm moving
		switch (mode)
		{
			case 0:
				// simply moving the cursor; any selection disappears
				if (direction == "left" || direction == "up")
				{
					pos = start;
				}
				else
				{
					pos = end;
				}
				break;
			case 1:
				// move the cursor; selection_start is retained
				pos = end;
				break;
			case 2:
				// move the selection_start; cursor is retained
				pos = start;
				break;
			default:
				return;
		}
		



		if (direction == "left")
		{
			do
			{
				pos --;
				if (typed_text.charAt(pos) == '$' )
				{
					dollar_sign_counts ++;
				}
			}
			while ( dollar_sign_counts % 2 != 0 && pos >= 0);


			if (pos < 0)
			{
				pos = 0;
			}
		}
		else if (direction == "right")
		{
			do
			{
				if (typed_text.charAt(pos) == '$' )
				{
					dollar_sign_counts ++;
				}
				pos ++;
			}
			while ( dollar_sign_counts % 2 != 0 && pos <= typed_text.length);


			if (pos > typed_text.length)
			{
				pos = typed_text.length;
			}
		}
		else if (direction == "up" || direction == "down")
		{

			// move up
			// figure out what is the current line and column of the cursor/selection
			// assuming I'm on the first line...
			pos_line = 0;
			pos_column = pos;
			// but possibly not.
//			alert(enter_positions);
//			alert(line_lengths);

			for (i = 0; i < enter_positions.length; i++)
			{
				if (pos > enter_positions[i])
				{
					pos_line = i + 1;
					pos_column = pos - enter_positions[i] - 1;
				}
				else
				{
					break;
				}
			}

//			alert('pos = ' + pos + ', pos_line = ' + pos_line + ', pos_column = ' + pos_column);

			// constrain the current line between two respective positions: (...)
			var prev_enter_position, next_enter_position, next_x2_enter_position;
			if (i == 0)
			{
				// because position == 0 is a valid character!
				prev_enter_position = -1;
			}
			else
			{
				prev_enter_position = enter_positions[i - 1];
			}

			if (i == enter_positions.length)
			{
				next_enter_position = typed_text.length;
			}
			else
			{
				next_enter_position = enter_positions[i];
			}

			if (i >= enter_positions.length - 1)
			{
				next_x2_enter_position = typed_text.length;
			}
			else
			{
				next_x2_enter_position = enter_positions[i + 1];
			}


			//
			var pos_column_glyph_aware;
			pos_column_glyph_aware = crawl_through_string(typed_text.substring(prev_enter_position + 1, pos));

			if (direction == "up")
			{
				if (pos_line == 0)
				{
					new_pos = 0;
				}
				else
				{
					if (pos_line == 1)
					{
						new_pos = 0;
					}
					else
					{
						new_pos = enter_positions[pos_line - 2] + 1;
					}

					/*
					if (pos_column > line_lengths[pos_line - 1])
					{
						pos_column = line_lengths[pos_line - 1];
					}

					new_pos += pos_column;*/
					new_pos += crawl_through_string(typed_text.substring(new_pos, prev_enter_position), pos_column_glyph_aware);
				}
			}
			else	// direction == "down"
			{
//				alert('move down, pos_line = ' + pos_line.toString() + ', pos_column_g_a = ' + pos_column_glyph_aware.toString());

				if (pos_line == enter_positions.length)
				{
					// cursor on the last line
					new_pos = typed_text.length;
				}
				else
				{
/*					if (pos_column > line_lengths[pos_line + 1])
					{
						pos_column = line_lengths[pos_line + 1];
					}

					new_pos = enter_positions[pos_line] + 1 + pos_column;
*/
					new_pos = enter_positions[pos_line] + 1;
					new_pos += crawl_through_string(typed_text.substring(new_pos, next_x2_enter_position), pos_column_glyph_aware);
				}
			}


			pos = new_pos;
		}
		else
		{
			alert("Error in function 'moveCursor': direction = '" + direction + "'");
		}


		// update start/end with revised value of pos
		switch (mode)
		{
			case 0:
				// simply moving the cursor; any selection disappears
				start = pos;
				end = pos;

				break;
			case 1:
				// move the cursor; selection_start is retained
				end = pos;
				break;
			case 2:
				// move the selection_start; cursor is retained
				start = pos;
				break;
			default:
				return;
		}




		selection_start = start;
		selection_end = end;

		renderTextToInnerHTML();

		var pos_char = "";
		// in "typed_text" string,
		// '$xxx$' is treated internally as Unicode emoji number "xxx"
		// '$0$' is '$'
		// '$-1$' is '&nbsp;'
		// '$-2$' is 7 non breaking spaces

		if (typed_text.charAt(pos) == '$' && pos < typed_text.length - 3)
		{
			if (typed_text.substring(pos, pos + 4) == "$-1$" || typed_text.substring(pos, pos + 4) == "$-2$")
			{
				pos_char = " ";
			}
			else
			{
				pos_char = "$";		// for what I care, a non-alphanumeric character
			}
		}
		else
		{
			if (pos < typed_text.length)
			{
				pos_char = typed_text.charAt(pos);
			}
		}


		return [pos_char, pos];
	}

	function moveCursorLeft()
	{
		moveCursor("left");
	}

	function moveCursorRight()
	{
		moveCursor("right");
	}

	function moveCursorUp()
	{
		moveCursor("up");
	}

	function moveCursorDown()
	{
		moveCursor("down");
	}

	

	function processEnterPositions()
	{
		// find '\n' symbols within text, and line lenghts

		/*
		const cursor_symbol  = "\u2026";			// horizontal ellipsis
		var selection_start = 0;				// handling cursor...
		var selection_end = 0;
		var typed_text = "";					// text typed by the user
		const enter_positions = [];
		const line_lengths = [];
		*/

		enter_positions.length = 0;
		line_lengths.length = 0;

		var i, prev_break = 0;
		for (i = 0; i < typed_text.length; i++)
		{
			if (typed_text.charAt(i) == '\n')
			{
				enter_positions.push(i);
				line_lengths.push(i - prev_break);
				prev_break = i + 1;
			}
		}

		// at least 1 line always...
		line_lengths.push(typed_text.length - prev_break);
	}

	function getLineForElement(el_pos)
	{
		// returns line number for the character at "el_pos" position
		processEnterPositions();

		var line_number = enter_positions.length;

		for (i = 0; i < enter_positions.length; i++)
		{
			if (el_pos <= enter_positions[i])
			{
				line_number = i;
				break;
			}
		}

		return line_number;
	}



	// const line_offsetTop = [];
	// var cursor_offsetTop = 0;

	function obtainLineOffsetTop()
	{
		// find vertical offsets of all the lines, and the cursor, of the text,
		// relative to the div vertical offset
		var nline;
		var span;
		line_offsetTop.length = 0;

		nline = 0;

		do
		{
			span = document.getElementById("span_line_" + nline);
			
			if (span != null)
			{
				line_offsetTop[nline] = span.offsetTop;
				nline ++;
			}
		}
		while(span != null);

		span = document.getElementById("span_cursor");
		if (span != null)
		{
			cursor_offsetTop = span.offsetTop;
		}
//		alert(line_offsetTop);
	}


	function renderTextToInnerHTML()
	{
		// from the pure text, stored internally,
		// get HTML to be placed inside div
		var i, nline;
		var html_text = "";

		// insert cursor after selection_end!
		var code_sel_start = "<span class = \"selection\">", code_sel_end = "</span>";
		const thin_space = "&thinsp;";

		var line_sel_start, line_sel_end, line_cursor;
		line_sel_start = getLineForElement(selection_start);
		line_sel_end   = getLineForElement(selection_end);
		line_cursor    = line_sel_end;

//		processEnterPositions();

		if (selection_start > selection_end)
		{
			[line_sel_start, line_sel_end] = [line_sel_end, line_sel_start];

			let empty_space_on_the_last_line = "";
			if (selection_start == typed_text.length)
			{
				empty_space_on_the_last_line = thin_space;
			}

			var typed_text_c = typed_text.substring(0, selection_end) + code_sel_start +
					   "<span id = \"span_cursor\">" + cursor_symbol + "</span>" + 
					   typed_text.substring(selection_end, selection_start) + 
				   	   empty_space_on_the_last_line + code_sel_end + 
					   typed_text.substring(selection_start);
		}
		else
		{
			var typed_text_c = typed_text.substring(0, selection_start) + code_sel_start +
			                   typed_text.substring(selection_start, selection_end) + code_sel_end + 
					   "<span id = \"span_cursor\">" +
					   cursor_symbol + "</span>" + typed_text.substring(selection_end);
		}



		// render for internal HTML
		nline = 0;
		html_text += "<span id = \"span_line_"+ nline + "\">";

		// opening_glyph is a state: 0 -> no glyph processing, 1 -> waiting for the second dollar sign
		var opening_glyph = 0, glyph_start, glyph_id;
		var wrap_span;

		for (i = 0; i < typed_text_c.length; i++)
		{
			if (typed_text_c.charAt(i) == '\n')
			{
				wrap_span = (nline >= line_sel_start && nline < line_sel_end);

//				if (line_lengths[nline] == 0)
//				{
					// add a thin space in case of an empty string
				html_text += thin_space;
//				}

				if (wrap_span)
				{
					html_text += code_sel_end;		// close selection for multi-line selections
				}

				html_text += "</span><br>";
				nline ++;

				html_text += "<span id = \"span_line_"+ nline + "\">";

				if (wrap_span)
				{
					html_text += code_sel_start;		// open selection for multi-line selections
				}
			}
			else if (typed_text_c.charAt(i) == '$')
			{
				if (opening_glyph == 0)
				{
					glyph_start = i + 1;
					opening_glyph = 1;
				}
				else
				{
					glyph_id = parseInt(typed_text_c.substring(glyph_start, i));
					// special characters
					// '$0$' is '$'
					if (isNaN(glyph_id) || glyph_id == 0)	// '$' sign
					{
						html_text += '$';
					}
					else if (glyph_id < 0)
					{

						switch (-glyph_id)
						{
							case 1:
								html_text += NBSP_1;
								// '$-1$' is '&nbsp;'
								break;
							case 2:
								html_text += NBSP_2;
								// '$-2$' is 7 non breaking spaces
								break;
							case 3:
								html_text += "&lt;";
								// '$-3$' is '<'
								break;
							case 4:
								html_text += "&gt;";
								// '$-4$' is '>'
								break;
							default:
								html_text += '&lt;unknown ID, '+ glyph_id.toString() +'&gt;';
								break;
						}

					}
					else
					{
						html_text += get_HTML_from_glyph_id(glyph_id, emoji_textfield_height);
					}

					opening_glyph = 0;
				}
			}
			else if (opening_glyph == 0)
			{
				html_text += typed_text_c.charAt(i);
			}
		}

//		html_text += thin_space;	// last line...?
		html_text += "</span>";
		
		document.getElementById("my_text_field").innerHTML = html_text;

//		obtainLineOffsetTop();
		update_scroll();
	}



	function update_scroll()
	{
		// find the scroll position of the div, to make cursor appear in-screen
		// and update the div scroll with it

//		current_scroll_top = 0;
//		var cursor_offsetTop = 0;
//		const line_height = 32;
//		const n_lines_in_div = 7;


		obtainLineOffsetTop();

		var current_cursor_vertical_position = (cursor_offsetTop - line_offsetTop[0]) - current_scroll_top;
		// new scroll position
		var new_offset = current_scroll_top;
		// the last on-screen line
		var max_offset = (n_lines_in_div - 1) * line_height;

		if (current_cursor_vertical_position < 0)
		{
			new_offset = (cursor_offsetTop - line_offsetTop[0]);
		}
		else if (current_cursor_vertical_position > max_offset )
		{
			new_offset = (cursor_offsetTop - line_offsetTop[0]) - max_offset;
		}


		current_scroll_top = new_offset;
		if (current_scroll_top < 0)
		{
			current_scroll_top = 0;
		}


		document.getElementById("my_text_field").scrollTop = current_scroll_top;


		// horizontal scroll

		var span = document.getElementById("span_cursor");
		var cursor_offsetLeft = 0;
		if (span != null)
		{
			cursor_offsetLeft = span.offsetLeft;
		}
//		document.getElementById("my_text_field").scrollLeft = cursor_offsetLeft - table_width/2;
		document.getElementById("my_text_field").scrollLeft = cursor_offsetLeft - table_width * 0.5;


	}



	function process_cell_widths()
	{
		// aligning right edges of table rows, adjusting the rightmost cell width
		var i, j, sum_spans, sum_keys, sum_width, table_row_width;
		const row_sum_spans = [], row_sum_keys = [];

		// calculate span sums
		j = 0;
		sum_spans = 0;
		sum_keys  = 0;
		for (i = 0; i < table_spans.length; i++) 
		{
			if (table_spans[i] != 0)
			{
				sum_spans += table_spans[i];
				sum_keys ++;
			}
			else
			{
				row_sum_spans[j] = sum_spans;
				row_sum_keys[j] = sum_keys;
				sum_spans = 0;
				sum_keys = 0;
				j++;
			}
		}

		// calculate cell widths

		j = 0;
		sum_width = 0;
		for (i = 0; i < table_spans.length; i++) 
		{
			table_row_width = table_width - (border_thickness) * (row_sum_keys[j] - 1);
			if (table_spans[i] != 0)
			{
				cell_widths[i] = Math.floor(table_spans[i] * table_row_width / row_sum_spans[j]);
				sum_width += cell_widths[i];
			}
			else
			{
				cell_widths[i]   = 0;
				cell_widths[i-1] += table_row_width - sum_width;
				sum_width = 0;
				j++;
			}
		}
	}


	function generate_table() 
	{
		process_cell_widths();

		// get the reference for the body
		var body = document.getElementsByTagName("body")[0];
	
		// creates a <table> element and a <tbody> element
		var tbl; 
		var tblBody; 

		// remove previous table, if it exists

		var removeTab;
		for (i = 0; i < current_number_of_rows; i++)
		{
			removeTab = document.getElementById('gen_table'+i);
			if (removeTab != null)
			{		
				var parentEl = removeTab.parentElement;
				parentEl.removeChild(removeTab);
			}
		}
		// alert(current_number_of_rows);
		current_number_of_rows = 0;


		// creating all cells
		var i, row_num, col_num;
		var row = document.createElement("tr");
		tbl = document.createElement("table");
		tbl.id = "gen_table" + current_number_of_rows;
		current_number_of_rows++;
		tblBody = document.createElement("tbody");

		row_num = 0;
		col_num = 0;

		for (i = 0; i < table_spans.length; i++) 
		{
		    // creates a table row
		    if (table_spans[i] == 0)
		    {
			    // add the row to the end of the table body
			    tblBody.appendChild(row);
			    // put the <tbody> in the <table>
			    tbl.appendChild(tblBody);
			    // appends <table> into <body>
			    body.appendChild(tbl);

			    row_num++;
			    col_num = 0;

			    if (i < table_spans.length - 1)
			    {
		 		    tbl = document.createElement("table");
				    tbl.id = "gen_table" + current_number_of_rows;
				    current_number_of_rows++;

				    tblBody = document.createElement("tbody");

				    row = document.createElement("tr");
			    }
			    else
			    {
				    tbl.style.borderBottom = border_thickness + "px solid " + color_keyboard; 
			    }
			    continue;
		    }
	
		      var cell = document.createElement("td");
		      var cell_id = "Key_"+ row_num +"_"+ col_num;

		      

		      cell.style.borderTop = border_thickness + "px solid " + color_keyboard;
		      
		      cell.style.userSelect = "none";
		     //-moz-user-select: none; -khtml-user-select: none; user-select: none;

		      cell.setAttribute("width", cell_widths[i]  + "px");
		      cell.setAttribute("height", cell_height);


	              cell.setAttribute("id", cell_id);

		      cell.addEventListener('click', cell_onclick);
		      cell.addEventListener('dblclick', cell_dblclick);
		      cell.addEventListener('touchstart', cell_ontouchstart);

		      row.appendChild(cell);

		      col_num++;
		    

		}

	}


	function myFunctionOnLoad() 
	{
		selection_start = 0;
		selection_end = 0;
		typed_text = "";
		current_scroll_top = 0;

		current_number_of_rows = 0;

		realize_normal_keyboard("rus");

		renderTextToInnerHTML();

		// init emojis
		load_emojis();
		populate_emoji_toc();
	}

	function realize_normal_keyboard(lang)
	{
		current_interface = "normal";

		init_main_keyboard();

		if (lang == "rus")
		{
			init_button_list_rus();
		}
		else if (lang == "eng")
		{
			init_button_list_eng();
		}
		else
		{
			alert('realize_normal_keyboard: unknown language ' + lang);
		}

//		alert(factor_2_3(65536));


		generate_table();
//		alert(update_table(0));
		update_table(1);

	}


	function process_keydown(event)
	{
		if (event.keyCode == 32 || event.keyCode == 13) 		// space (32) or enter (13)
		{
			apply_choice();
		}
		else if ( event.keyCode >= 37 && event.keyCode <= 38 )		// 'left' arrow (37) or 'up' arrow (38)
		{
			change_choice(-1);
		}
		else if ( event.keyCode >= 39 && event.keyCode <= 40 )		// 'right' arrow (39) or 'down' arrow (40)
		{
			change_choice(1);
		}
		else if (event.keyCode == 8)					// backspace
		{
			undo_choice();
		}
	}


	function process_paste(event)
	{
		let paste = (event.clipboardData || window.clipboardData).getData('text');

		if (current_interface != "paste")
		{
			paste_data (paste);
		}
	}




	window.onload = myFunctionOnLoad;
	document.addEventListener("keydown", process_keydown);

	document.addEventListener("paste", process_paste);


	/*
	function test_dict()
	{
		var my_cell = document.getElementById("Key_5_0");
		var cl_wid, cl_wid2;

		init_eng_dict();

		var max_length = new Array(1000);
		var max_word   = new Array(1000);
		var i;
		for (i = 0; i< max_length.length; i++)
		{
			max_length[i] = 0;
			max_word[i] = "";
		}

		for (i = 0; i< dictionary.length; i++)
		{
			my_cell.innerHTML = "<span id=\"wordlentest\">" + dictionary[i] + "</span>";
			cl_wid  = document.getElementById("wordlentest").offsetWidth;

			if (cl_wid > max_length[ dictionary[i].length ])
			{
				max_length[ dictionary[i].length ] = cl_wid;
				max_word[dictionary[i].length] = dictionary[i];
			}
		}

		var out = "";		

		for (i = 0; i< 100; i++)
		{
			out += i.toString() + "\t" + max_length[i] + "\t" + max_word[i] + "\n";
		}

		alert(out);
	}
	*/


</script>



</head>
<body style="background-color:#a0a0a0;">

<div id="my_text_field" onscroll="update_scroll();" >
</div>
<p>

</body>
</html>

